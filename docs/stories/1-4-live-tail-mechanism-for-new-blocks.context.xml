<story-context id="1-4-live-tail-mechanism-for-new-blocks" v="1.0">
  <metadata>
    <epicId>1</epicId>
    <storyId>1.4</storyId>
    <title>Live-Tail Mechanism for New Blocks</title>
    <status>drafted</status>
    <generatedAt>2025-10-30</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/stories/1-4-live-tail-mechanism-for-new-blocks.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>blockchain indexer system</asA>
    <iWant>a live-tail coordinator that sequentially processes new blocks as they are produced on the Ethereum network</iWant>
    <soThat>I can maintain near real-time synchronization with the blockchain head with &lt;2 second lag</soThat>
    <tasks>
      <task id="1" ac="1,5">
        <name>Design live-tail coordinator architecture</name>
        <subtasks>
          <subtask id="1.1">Design LiveTailCoordinator struct with RPC client, ingester, store, poll interval</subtask>
          <subtask id="1.2">Design sequential processing loop with time.Ticker</subtask>
          <subtask id="1.3">Design database head query pattern before each block fetch</subtask>
          <subtask id="1.4">Design context cancellation handling for graceful shutdown</subtask>
          <subtask id="1.5">Document design patterns and integration points</subtask>
        </subtasks>
      </task>
      <task id="2" ac="1,2">
        <name>Implement sequential block processing</name>
        <subtasks>
          <subtask id="2.1">Create internal/index/livetail.go with LiveTailCoordinator struct</subtask>
          <subtask id="2.2">Implement Start(ctx) method with ticker loop</subtask>
          <subtask id="2.3">Implement processNextBlock(ctx) method with head query and block fetch</subtask>
          <subtask id="2.4">Handle "block not found" case (next block not yet produced)</subtask>
          <subtask id="2.5">Integrate with ingestion layer (parse block → domain model)</subtask>
          <subtask id="2.6">Integrate with storage layer (insert block via store interface)</subtask>
        </subtasks>
      </task>
      <task id="3" ac="3">
        <name>Implement error handling and resilience</name>
        <subtasks>
          <subtask id="3.1">Log errors with structured context (block height, error type)</subtask>
          <subtask id="3.2">Continue processing after errors (don't halt coordinator)</subtask>
          <subtask id="3.3">Rely on RPC client retry logic for transient failures</subtask>
          <subtask id="3.4">Handle context cancellation gracefully (stop ticker, clean up)</subtask>
        </subtasks>
      </task>
      <task id="4" ac="4">
        <name>Integrate with reorg handler</name>
        <subtasks>
          <subtask id="4.1">Query database for parent block hash</subtask>
          <subtask id="4.2">Compare fetched block's parent hash with database head hash</subtask>
          <subtask id="4.3">If mismatch detected, log warning and trigger reorg handler</subtask>
          <subtask id="4.4">Create ReorgHandler interface stub (Story 1.5 not yet implemented)</subtask>
          <subtask id="4.5">Pass reorg handling context to stub (no-op for now)</subtask>
        </subtasks>
      </task>
      <task id="5" ac="5">
        <name>Add configuration and metrics</name>
        <subtasks>
          <subtask id="5.1">Create internal/index/livetail_config.go with configuration struct</subtask>
          <subtask id="5.2">Load poll interval from LIVETAIL_POLL_INTERVAL environment variable (default: 2s)</subtask>
          <subtask id="5.3">Add Prometheus metrics (blocks_processed_total, current_head_height, lag_seconds)</subtask>
          <subtask id="5.4">Log block processing events with structured fields (height, hash, lag)</subtask>
          <subtask id="5.5">Calculate and log lag between network head and database head</subtask>
        </subtasks>
      </task>
      <task id="6" ac="1,2,3,4,5">
        <name>Write comprehensive tests</name>
        <subtasks>
          <subtask id="6.1">Create internal/index/livetail_test.go with mocked RPC and database</subtask>
          <subtask id="6.2">Test sequential processing (process 5 blocks in order)</subtask>
          <subtask id="6.3">Test polling with ticker (verify 2-second cadence)</subtask>
          <subtask id="6.4">Test "block not found" case (next block not yet produced)</subtask>
          <subtask id="6.5">Test context cancellation (graceful shutdown)</subtask>
          <subtask id="6.6">Test configuration validation and loading</subtask>
          <subtask id="6.7">Test parent hash mismatch detection (reorg scenario)</subtask>
          <subtask id="6.8">Achieve &gt;70% test coverage for livetail package</subtask>
        </subtasks>
      </task>
    </tasks>
  </story>

  <acceptanceCriteria>
    <criterion id="1">
      <name>Sequential Block Processing</name>
      <description>Fetches next block sequentially from database head + 1. Processes blocks one at a time (no parallelization). Queries database for current head height before each fetch. Maintains strict height ordering (no gaps or duplicates).</description>
    </criterion>
    <criterion id="2">
      <name>Polling and Timing</name>
      <description>Polls for new blocks at configurable interval (default: 2 seconds). Uses time.Ticker for precise polling cadence. Lag between network head and database head &lt; 2 seconds (averaged over 1 minute). Handles "block not found" gracefully (network hasn't produced next block yet).</description>
    </criterion>
    <criterion id="3">
      <name>Error Handling and Resilience</name>
      <description>Continues processing despite transient RPC errors (no halt). Logs errors with context but doesn't exit. RPC client retry logic handles transient failures automatically. Permanent errors (e.g., network unreachable) logged but polling continues.</description>
    </criterion>
    <criterion id="4">
      <name>Integration with Reorg Handler</name>
      <description>Checks for parent hash mismatch before inserting block. Triggers reorg handler if parent hash doesn't match database head. Delegates reorg handling to ReorgHandler (Story 1.5 - not yet implemented, stub OK). Continues normal processing after reorg resolution.</description>
    </criterion>
    <criterion id="5">
      <name>Configuration and Observability</name>
      <description>Poll interval configurable via LIVETAIL_POLL_INTERVAL environment variable. Structured logging for: block processed, parent mismatch detected, errors. Metrics: blocks_processed_total counter, current_head_height gauge, lag_seconds gauge. Context cancellation support for graceful shutdown.</description>
    </criterion>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/tech-spec-epic-1.md</path>
        <title>Tech Spec: Epic 1 - Core Indexing &amp; Data Pipeline</title>
        <section>Story 1.4: Live-Tail Mechanism for New Blocks</section>
        <snippet>Live-tail coordinator polls for new blocks sequentially. Maintains &lt;2s lag from network head. Checks parent hash for reorg detection. Uses time.Ticker for precise 2-second polling cadence.</snippet>
      </doc>
      <doc>
        <path>docs/tech-spec-epic-1.md</path>
        <title>Tech Spec: Epic 1 - Core Indexing &amp; Data Pipeline</title>
        <section>Component Responsibilities by Data Model</section>
        <snippet>Indexing Layer (Live-Tail): Fetch next sequential block from DB head height + 1. Method: processNextBlock(). Integrates with ReorgHandler for parent hash mismatch detection.</snippet>
      </doc>
      <doc>
        <path>docs/PRD.md</path>
        <title>Product Requirements Document</title>
        <section>FR002: Real-Time Block Monitoring</section>
        <snippet>System shall maintain live synchronization with Ethereum blockchain head with &lt;2 second lag (averaged over 1 minute window).</snippet>
      </doc>
      <doc>
        <path>docs/solution-architecture.md</path>
        <title>Solution Architecture</title>
        <section>Indexing Layer</section>
        <snippet>Live-tail coordinator processes blocks sequentially as they are produced. Uses ticker-based polling. Detects parent hash mismatch for reorg scenarios.</snippet>
      </doc>
    </docs>
    <code>
      <artifact>
        <path>internal/index/backfill.go</path>
        <kind>interface</kind>
        <symbol>RPCBlockFetcher</symbol>
        <lines>14-17</lines>
        <reason>REUSE: Interface for mocking RPC client in tests. Already defined in Story 1.3. Live-tail can use the same interface pattern.</reason>
      </artifact>
      <artifact>
        <path>internal/rpc/client.go</path>
        <kind>service</kind>
        <symbol>Client</symbol>
        <lines>18-23</lines>
        <reason>RPC client with retry logic. Live-tail will use Client.GetBlockByNumber() to fetch blocks. Implements RPCBlockFetcher interface.</reason>
      </artifact>
      <artifact>
        <path>internal/index/backfill.go</path>
        <kind>coordinator</kind>
        <symbol>BackfillCoordinator</symbol>
        <lines>19-30</lines>
        <reason>Reference pattern for coordinator struct design. Live-tail coordinator will follow similar structure (rpcClient, config, logger, metrics).</reason>
      </artifact>
      <artifact>
        <path>internal/index/backfill_config.go</path>
        <kind>configuration</kind>
        <symbol>Config</symbol>
        <lines>full file</lines>
        <reason>Reference pattern for environment variable configuration. Live-tail config will follow same pattern for LIVETAIL_POLL_INTERVAL.</reason>
      </artifact>
      <artifact>
        <path>internal/index/backfill_test.go</path>
        <kind>test</kind>
        <symbol>MockRPCClient</symbol>
        <lines>full file</lines>
        <reason>Reference mocking pattern for RPCBlockFetcher interface. Live-tail tests will follow same mock pattern.</reason>
      </artifact>
    </code>
    <dependencies>
      <go>
        <package name="github.com/ethereum/go-ethereum" version="v1.16.5">Ethereum RPC client and types.Block structures</package>
        <package name="github.com/jackc/pgx/v5" version="v5.7.6">PostgreSQL driver for database head queries</package>
        <package name="github.com/prometheus/client_golang" version="v1.19.0">Prometheus metrics (counters and gauges)</package>
        <package name="github.com/stretchr/testify" version="v1.10.0">Testing framework (assert, require, mock)</package>
        <package name="log/slog" version="stdlib">Structured JSON logging</package>
        <package name="time" version="stdlib">time.Ticker for polling cadence</package>
        <package name="context" version="stdlib">Context for cancellation support</package>
      </go>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint>Sequential processing only - no parallelization for live-tail (contrast with Story 1.3 parallel backfill)</constraint>
    <constraint>Must query database head before each block fetch to ensure sequential ordering</constraint>
    <constraint>Error handling: log and continue (do NOT halt on errors like Story 1.3 backfill)</constraint>
    <constraint>Use time.Ticker for precise 2-second polling interval (not time.Sleep in loop)</constraint>
    <constraint>Context cancellation must cleanly stop ticker and exit goroutine</constraint>
    <constraint>Reorg Handler is Story 1.5 (not yet implemented) - create interface stub only</constraint>
    <constraint>Ingestion layer domain model conversion may be stubbed (focus on RPC fetch and DB insert)</constraint>
    <constraint>Follow Story 1.3 patterns: structured logging (slog + JSON), env var config, interface-based mocking</constraint>
    <constraint>Prometheus metrics collected but not emitted (Story 1.7 handles emission)</constraint>
    <constraint>Test coverage target: &gt;70% (same as Story 1.3)</constraint>
  </constraints>

  <interfaces>
    <interface>
      <name>RPCBlockFetcher</name>
      <kind>Go interface</kind>
      <signature>type RPCBlockFetcher interface { GetBlockByNumber(ctx context.Context, height uint64) (*types.Block, error) }</signature>
      <path>internal/index/backfill.go:14-17</path>
      <note>REUSE from Story 1.3. Live-tail coordinator will accept RPCBlockFetcher for testability.</note>
    </interface>
    <interface>
      <name>Store (future)</name>
      <kind>Go interface (to be defined)</kind>
      <signature>type Store interface { GetLatestBlock(ctx) (*Block, error); InsertBlock(ctx, *Block) error }</signature>
      <path>internal/store/store.go (not yet created)</path>
      <note>Storage layer interface for head queries and block insertion. May be stubbed for Story 1.4.</note>
    </interface>
    <interface>
      <name>ReorgHandler (future Story 1.5)</name>
      <kind>Go interface (stub)</kind>
      <signature>type ReorgHandler interface { HandleReorg(ctx, *Block) error }</signature>
      <path>internal/index/reorg.go (not yet created)</path>
      <note>Reorg handler interface stub. Live-tail will call on parent hash mismatch. No-op implementation for Story 1.4.</note>
    </interface>
    <interface>
      <name>Ingester (future)</name>
      <kind>Go interface (stub)</kind>
      <signature>type Ingester interface { ParseBlock(*types.Block) (*DomainBlock, error) }</signature>
      <path>internal/ingest/ingester.go (not yet created)</path>
      <note>Ingestion layer for RPC block → domain model conversion. May be stubbed for Story 1.4.</note>
    </interface>
  </interfaces>

  <tests>
    <standards>
      Testing framework: Go standard library testing + testify (assert, require, mock). Target coverage: &gt;70% for all packages. Use table-driven tests for configuration validation. Mock external dependencies via interfaces (RPCBlockFetcher, Store, ReorgHandler). Follow Story 1.3 test patterns: context cancellation tests, error resilience tests, performance/throughput tests. File naming: *_test.go in same package. Run with: go test ./internal/index/... -cover
    </standards>
    <locations>
      <location>internal/index/livetail_test.go</location>
      <location>internal/index/*_test.go (follow Story 1.3 pattern)</location>
    </locations>
    <ideas>
      <idea ac="1">Test sequential block processing: Mock Store.GetLatestBlock() returns heights 100, 101, 102... Mock RPC returns blocks for 101, 102, 103... Verify coordinator fetches in order.</idea>
      <idea ac="2">Test ticker polling: Use time.NewTicker(100ms) for fast test. Verify ticker fires at regular intervals. Count number of processNextBlock() calls over fixed duration.</idea>
      <idea ac="2">Test "block not found": Mock RPC returns nil for next block (not yet produced). Verify coordinator logs at DEBUG level and continues polling without error.</idea>
      <idea ac="3">Test error resilience: Mock RPC returns error for one block fetch. Verify coordinator logs error and continues to next tick (doesn't halt).</idea>
      <idea ac="3">Test context cancellation: Start coordinator, wait for 2 ticks, cancel context. Verify ticker stops cleanly and goroutine exits.</idea>
      <idea ac="4">Test parent hash mismatch: Mock Store.GetLatestBlock() returns block with hash A. Mock RPC returns block with parent hash B (!= A). Verify ReorgHandler.HandleReorg() called.</idea>
      <idea ac="5">Test configuration: Set LIVETAIL_POLL_INTERVAL=5s env var. Verify Config.PollInterval == 5 seconds. Test default (2s) when env var not set.</idea>
      <idea ac="5">Test metrics: Process 3 blocks. Verify blocks_processed_total == 3, current_head_height == 103 (if starting at 100).</idea>
    </ideas>
  </tests>
</story-context>
