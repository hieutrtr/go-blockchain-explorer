# Story 2.1: REST API Endpoints for Blockchain Queries

Status: review

## Story

As a **blockchain data consumer (developer, analyst, or frontend application)**,
I want **RESTful API endpoints to query indexed blockchain data (blocks, transactions, address history, logs, and chain statistics)**,
so that **I can access blockchain information via standard HTTP requests with sub-150ms response times and pagination support**.

## Acceptance Criteria

1. **AC1: API Server Setup and Routing**
   - HTTP server running on configurable port (default: 8080, via API_PORT environment variable)
   - chi router configured with middleware stack (CORS, logging, metrics, recovery)
   - API routes mounted under `/v1` prefix for versioning
   - Static file serving for frontend SPA from `./web` directory
   - Graceful shutdown handling (signal catching, connection draining)

2. **AC2: Block Query Endpoints**
   - `GET /v1/blocks?limit={n}&offset={m}` - List recent blocks (default limit=25, max=100)
   - `GET /v1/blocks/{height}` - Get block by height (returns 404 if not found)
   - `GET /v1/blocks/{hash}` - Get block by hash (returns 404 if not found)
   - Response includes: height, hash, parent_hash, miner, gas_used, gas_limit, timestamp, tx_count, orphaned flag
   - Pagination responses include: blocks array, total count, limit, offset
   - Only non-orphaned blocks returned by default

3. **AC3: Transaction Query Endpoint**
   - `GET /v1/txs/{hash}` - Get transaction by hash (returns 404 if not found)
   - Response includes: hash, block_height, tx_index, from_addr, to_addr (nullable), value_wei, fee_wei, gas_used, gas_price, nonce, success status
   - Hex-encoded addresses and hashes prefixed with `0x`

4. **AC4: Address Transaction History**
   - `GET /v1/address/{addr}/txs?limit={n}&offset={m}` - Get transactions for address (sent or received)
   - Response includes: address, transactions array (with timestamp from block), total count, limit, offset
   - Address validation (40 hex characters after `0x` prefix)
   - Default limit=50, max=100

5. **AC5: Event Log Filtering**
   - `GET /v1/logs?address={addr}&topic0={topic}&limit={n}&offset={m}` - Query event logs
   - Filter parameters: address (optional), topic0 (optional), limit (default=100, max=1000), offset (default=0)
   - Response includes: logs array (tx_hash, log_index, address, topics[0-3], data), total count, limit, offset
   - Efficient queries using composite index on (address, topic0)

6. **AC6: Chain Statistics Endpoint**
   - `GET /v1/stats/chain` - Get current chain statistics
   - Response includes: latest_block (height), total_blocks, total_transactions, indexer_lag_blocks, indexer_lag_seconds, last_updated (ISO8601 timestamp)
   - Statistics computed from database (SELECT MAX, COUNT queries)

7. **AC7: Health Check Endpoint**
   - `GET /health` - System health check
   - Returns HTTP 200 + JSON when healthy: `{status: "healthy", database: "connected", indexer_last_block, indexer_last_updated, indexer_lag_seconds, version}`
   - Returns HTTP 503 + JSON when unhealthy: `{status: "unhealthy", database: "disconnected", errors: [...]}`
   - Database connectivity tested via `SELECT 1` query

8. **AC8: Prometheus Metrics Endpoint**
   - `GET /metrics` - Expose Prometheus metrics
   - Metrics include: `explorer_api_requests_total` (counter with labels: method, endpoint, status), `explorer_api_latency_ms` (histogram with labels: method, endpoint)
   - Uses `promhttp.Handler()` from prometheus/client_golang
   - Metrics updated via middleware on every API request

9. **AC9: Input Validation and Error Handling**
   - Validate pagination parameters (limit > 0, offset >= 0, limit <= max)
   - Validate Ethereum addresses (0x + 40 hex chars)
   - Validate hashes (0x + 64 hex chars for tx hashes, 0x + 64 for block hashes)
   - Return HTTP 400 for invalid inputs with structured JSON error: `{error: "message", details: "..."}`
   - Return HTTP 404 for not-found resources
   - Return HTTP 500 for internal errors (with error logged, generic message returned)

10. **AC10: CORS and Security Configuration**
    - CORS middleware allows configurable origins (default: `*` for demo)
    - CORS configuration via API_CORS_ORIGINS environment variable
    - Request timeout configured (default: 30 seconds)
    - No authentication required (public API for demo/portfolio)

11. **AC11: API Performance**
    - p95 latency < 150ms for block/transaction queries (measured under realistic load)
    - Database connection pooling configured (max 10 connections for API)
    - Prepared statements used where applicable
    - Composite indexes on database tables ensure efficient queries

12. **AC12: Logging and Observability**
    - All API requests logged with structured logger (method, path, status, latency, error if any)
    - Use structured logger from `internal/util/logger.go` (Story 1.8)
    - Errors logged with full context (stack trace for 500 errors)
    - Startup logs: server port, database connection status, routes registered

## Tasks / Subtasks

- [ ] **Task 1: Create API server entry point** (AC: #1, #12)
  - [ ] Subtask 1.1: Create `cmd/api/main.go` with server initialization
  - [ ] Subtask 1.2: Load configuration from environment variables (API_PORT, DB_HOST, DB_PORT, DB_NAME, DB_USER, DB_PASSWORD, DB_MAX_CONNS, API_CORS_ORIGINS)
  - [ ] Subtask 1.3: Initialize database connection pool using pgx (max 10 connections)
  - [ ] Subtask 1.4: Initialize structured logger from `internal/util/logger.go`
  - [ ] Subtask 1.5: Create API server instance and start HTTP listener
  - [ ] Subtask 1.6: Add graceful shutdown handler (os.Signal for SIGINT/SIGTERM)
  - [ ] Subtask 1.7: Test server startup and shutdown

- [ ] **Task 2: Implement API server with chi router** (AC: #1, #10)
  - [ ] Subtask 2.1: Create `internal/api/server.go` with Server struct (holds db pool, logger, config)
  - [ ] Subtask 2.2: Implement `NewServer()` constructor
  - [ ] Subtask 2.3: Implement `Router()` method returning configured chi.Router
  - [ ] Subtask 2.4: Add middleware stack: chi.Logger, chi.Recoverer, CORS middleware, metrics middleware
  - [ ] Subtask 2.5: Register routes under `/v1` prefix for API versioning
  - [ ] Subtask 2.6: Add static file serving for frontend (`web/` directory)
  - [ ] Subtask 2.7: Test router configuration and middleware execution

- [ ] **Task 3: Implement middleware** (AC: #8, #10, #12)
  - [ ] Subtask 3.1: Create `internal/api/middleware.go`
  - [ ] Subtask 3.2: Implement CORS middleware (configurable origins, preflight handling)
  - [ ] Subtask 3.3: Implement metrics middleware (record request count, latency)
  - [ ] Subtask 3.4: Implement logging middleware (log method, path, status, latency)
  - [ ] Subtask 3.5: Test middleware in isolation

- [ ] **Task 4: Implement block query handlers** (AC: #2, #9, #11)
  - [ ] Subtask 4.1: Create `internal/api/handlers.go` (or `handlers/blocks.go`)
  - [ ] Subtask 4.2: Implement `handleListBlocks` (GET /v1/blocks with pagination)
  - [ ] Subtask 4.3: Implement `handleGetBlockByHeight` (GET /v1/blocks/:height)
  - [ ] Subtask 4.4: Implement `handleGetBlockByHash` (GET /v1/blocks/:hash)
  - [ ] Subtask 4.5: Add input validation (pagination limits, height/hash format)
  - [ ] Subtask 4.6: Add database queries with proper indexing (use `idx_blocks_orphaned_height`)
  - [ ] Subtask 4.7: Test handlers with mock database

- [ ] **Task 5: Implement transaction query handler** (AC: #3, #9)
  - [ ] Subtask 5.1: Implement `handleGetTransaction` (GET /v1/txs/:hash)
  - [ ] Subtask 5.2: Validate transaction hash format (0x + 64 hex chars)
  - [ ] Subtask 5.3: Query transactions table by hash (primary key lookup)
  - [ ] Subtask 5.4: Return 404 if transaction not found
  - [ ] Subtask 5.5: Test handler with mock database

- [ ] **Task 6: Implement address transaction history handler** (AC: #4, #9, #11)
  - [ ] Subtask 6.1: Implement `handleGetAddressTransactions` (GET /v1/address/:addr/txs)
  - [ ] Subtask 6.2: Validate address format (0x + 40 hex chars)
  - [ ] Subtask 6.3: Query transactions where from_addr = addr OR to_addr = addr (use composite indexes)
  - [ ] Subtask 6.4: Apply pagination (limit/offset)
  - [ ] Subtask 6.5: Join with blocks table to get timestamp
  - [ ] Subtask 6.6: Test handler with mock database

- [ ] **Task 7: Implement event log filtering handler** (AC: #5, #9, #11)
  - [ ] Subtask 7.1: Implement `handleQueryLogs` (GET /v1/logs)
  - [ ] Subtask 7.2: Parse query parameters: address, topic0, limit, offset
  - [ ] Subtask 7.3: Build dynamic SQL query based on provided filters
  - [ ] Subtask 7.4: Use composite index `idx_logs_address_topic0` for efficient filtering
  - [ ] Subtask 7.5: Apply pagination (limit/offset, max limit=1000)
  - [ ] Subtask 7.6: Test handler with various filter combinations

- [ ] **Task 8: Implement chain statistics handler** (AC: #6)
  - [ ] Subtask 8.1: Implement `handleChainStats` (GET /v1/stats/chain)
  - [ ] Subtask 8.2: Query database for: MAX(height), COUNT(*) from blocks, COUNT(*) from transactions
  - [ ] Subtask 8.3: Calculate indexer lag (compare latest block timestamp to current time)
  - [ ] Subtask 8.4: Format response with ISO8601 timestamps
  - [ ] Subtask 8.5: Test handler with mock database

- [ ] **Task 9: Implement health check handler** (AC: #7)
  - [ ] Subtask 9.1: Create `internal/api/handlers/health.go`
  - [ ] Subtask 9.2: Implement `handleHealth` (GET /health)
  - [ ] Subtask 9.3: Test database connectivity with `SELECT 1` query
  - [ ] Subtask 9.4: Query latest block from database (height, updated_at)
  - [ ] Subtask 9.5: Return HTTP 200 if healthy, HTTP 503 if unhealthy
  - [ ] Subtask 9.6: Test handler with healthy and unhealthy database states

- [ ] **Task 10: Implement metrics endpoint** (AC: #8)
  - [ ] Subtask 10.1: Create `internal/api/metrics.go`
  - [ ] Subtask 10.2: Define Prometheus metrics: `explorer_api_requests_total` (counter), `explorer_api_latency_ms` (histogram)
  - [ ] Subtask 10.3: Register metrics in middleware (update on every request)
  - [ ] Subtask 10.4: Expose metrics at GET /metrics using `promhttp.Handler()`
  - [ ] Subtask 10.5: Test metrics exposure and incrementation

- [ ] **Task 11: Implement pagination utilities** (AC: #2, #4, #5, #9)
  - [ ] Subtask 11.1: Create `internal/api/pagination.go`
  - [ ] Subtask 11.2: Implement `parsePagination(r *http.Request) (limit, offset int)` function
  - [ ] Subtask 11.3: Validate limit > 0, offset >= 0, limit <= max
  - [ ] Subtask 11.4: Apply defaults (limit=25 for blocks, limit=50 for txs, limit=100 for logs)
  - [ ] Subtask 11.5: Test pagination parsing and validation

- [ ] **Task 12: Implement error handling utilities** (AC: #9, #12)
  - [ ] Subtask 12.1: Create `internal/api/errors.go`
  - [ ] Subtask 12.2: Implement `handleError(w, err, statusCode)` function
  - [ ] Subtask 12.3: Implement `writeJSON(w, statusCode, data)` function
  - [ ] Subtask 12.4: Log errors with structured logger and context
  - [ ] Subtask 12.5: Return standardized JSON error responses

- [ ] **Task 13: Add unit tests for API handlers** (AC: all)
  - [ ] Subtask 13.1: Create `internal/api/handlers_test.go`
  - [ ] Subtask 13.2: Test block handlers (success, not found, invalid input)
  - [ ] Subtask 13.3: Test transaction handler (success, not found, invalid hash)
  - [ ] Subtask 13.4: Test address transaction handler (success, pagination, invalid address)
  - [ ] Subtask 13.5: Test log filtering handler (success, various filters)
  - [ ] Subtask 13.6: Test chain stats handler (success)
  - [ ] Subtask 13.7: Test health check handler (healthy, unhealthy)
  - [ ] Subtask 13.8: Achieve >70% test coverage for API handlers

- [ ] **Task 14: Add integration tests with test database** (AC: #11)
  - [ ] Subtask 14.1: Create test database setup/teardown utilities
  - [ ] Subtask 14.2: Insert test fixtures (blocks, transactions, logs)
  - [ ] Subtask 14.3: Test end-to-end API requests with real database
  - [ ] Subtask 14.4: Measure query latency and verify p95 < 150ms
  - [ ] Subtask 14.5: Test pagination edge cases (offset beyond total, large limits)

- [ ] **Task 15: Performance testing and optimization** (AC: #11)
  - [ ] Subtask 15.1: Load test with 100 concurrent requests using realistic data
  - [ ] Subtask 15.2: Measure p95 latency for each endpoint
  - [ ] Subtask 15.3: Verify composite indexes are being used (EXPLAIN ANALYZE)
  - [ ] Subtask 15.4: Optimize slow queries if p95 > 150ms
  - [ ] Subtask 15.5: Document performance test results

## Dev Notes

### Architecture Context

**Component:** `internal/api/` package (API server and handlers)

**Key Design Patterns:**
- **Layered Architecture:** API layer → Storage layer → Database (no direct business logic in handlers)
- **Dependency Injection:** Server struct holds dependencies (db pool, logger, config)
- **Middleware Pattern:** Cross-cutting concerns (CORS, logging, metrics) handled via chi middleware
- **Repository Pattern:** Database queries abstracted in `internal/store/pg/` package (shared with indexer)

**Integration Points:**
- **Database** (`internal/store/pg/`): Read-only queries for blocks, transactions, logs
- **Logger** (`internal/util/logger.go`): Structured logging for all API requests and errors (Story 1.8)
- **Metrics** (Prometheus): API-specific metrics exposed at `/metrics` endpoint

**Technology Stack:**
- chi v5 router (lightweight, idiomatic, excellent middleware support)
- pgx v5 driver (high-performance PostgreSQL driver with connection pooling)
- prometheus/client_golang (official Prometheus client for Go)
- Standard library: net/http, encoding/json, context

### Project Structure Notes

**Files to Create:**
```
cmd/api/
├── main.go                    # API server entry point

internal/api/
├── server.go                  # API server setup and routing
├── middleware.go              # CORS, metrics, logging middleware
├── handlers.go                # Block, transaction, address handlers
├── handlers/
│   ├── blocks.go              # Block query handlers
│   ├── txs.go                 # Transaction query handlers
│   ├── address.go             # Address history handler
│   ├── logs.go                # Event log filtering handler
│   ├── stats.go               # Chain statistics handler
│   └── health.go              # Health check handler
├── pagination.go              # Pagination utilities
├── errors.go                  # Error handling utilities
├── metrics.go                 # Prometheus metrics definitions
├── handlers_test.go           # Unit tests for handlers
└── integration_test.go        # Integration tests with test database

web/
├── index.html                 # Frontend SPA (Story 2.4)
├── app.js                     # Frontend JavaScript (Story 2.4)
└── style.css                  # Frontend CSS (Story 2.4)
```

**Configuration:**
```bash
# API Server
API_PORT=8080
API_CORS_ORIGINS=*
API_TIMEOUT=30s

# Database (read-only for API)
DB_HOST=localhost
DB_PORT=5432
DB_NAME=blockchain_explorer
DB_USER=postgres
DB_PASSWORD=postgres
DB_MAX_CONNS=10  # Lower than indexer (separate pool)

# Logging
LOG_LEVEL=INFO

# Metrics
METRICS_PORT=9090
```

### Learnings from Previous Story

**From Story 1.8: Structured Logging for Debugging (Status: done)**

**Key Patterns to Reuse:**
- **Global Logger Pattern:** Use `util.GlobalLogger` with `util.Info()`, `util.Warn()`, `util.Error()`, `util.Debug()` functions - no need to pass logger as dependency
- **Environment Variable Configuration:** LOG_LEVEL pattern established - apply same pattern to API_PORT, API_CORS_ORIGINS
- **Structured Logging Format:** JSON output with key-value attributes (method, path, status, latency, error)
- **Thread-Safe Operations:** Logger is thread-safe for concurrent usage (verified with 50 goroutines)
- **Source Location in Logs:** `AddSource: true` includes file/line info in logs for debugging

**New Capabilities Available:**
- Structured logger already initialized - import `internal/util` and use `util.Info()`, `util.Warn()`, `util.Error()`
- No need to create local logger instances or pass logger parameters
- Logging middleware can use global logger for request logging
- Error handlers can use global logger for error context

**Integration Notes:**
- API server should initialize global logger in `cmd/api/main.go` before starting server
- Middleware logs: `util.Info("API request", "method", method, "path", path, "status", status, "latency_ms", latency)`
- Error logs: `util.Error("API error", "method", method, "path", path, "error", err.Error())`
- Startup logs: `util.Info("Starting API server", "port", port, "cors_origins", corsOrigins)`

**Previous Story File List (Reference):**
- `internal/util/logger.go` - Core logger module (NEW in Story 1.8)
- `internal/util/logger_test.go` - Logger tests with 87.7% coverage
- `internal/rpc/client.go` - RPC client uses global logger
- `internal/db/connection.go` - Database connection uses global logger
- `cmd/worker/main.go` - Worker main uses global logger

### Performance Considerations

**Database Connection Pooling:**
- API server uses separate connection pool from indexer (max 10 connections)
- pgx pool configuration: `MaxConns: 10, MinConns: 2, MaxConnLifetime: 1 hour`
- Connection pool shared across all API handlers

**Query Optimization:**
- Use composite indexes for common queries:
  - `idx_blocks_orphaned_height` for block list queries
  - `idx_tx_from_addr_block` and `idx_tx_to_addr_block` for address history
  - `idx_logs_address_topic0` for event log filtering
- Use `LIMIT` and `OFFSET` for pagination (acceptable for demo scale)
- Use parameterized queries to prevent SQL injection and enable query plan caching

**Response Time Targets:**
- Block query by height/hash: < 50ms p95 (primary key or unique index lookup)
- Transaction query by hash: < 50ms p95 (primary key lookup)
- Address transaction history: < 150ms p95 (composite index scan)
- Event log filtering: < 150ms p95 (composite index scan)
- Chain statistics: < 100ms p95 (COUNT/MAX aggregations)

**Latency Measurement:**
- Use Prometheus histogram `explorer_api_latency_ms` with buckets: [10, 25, 50, 100, 150, 200, 500, 1000]
- Measure latency in middleware before sending response
- Log slow queries (>200ms) at WARN level

### Testing Strategy

**Unit Test Coverage Target:** >70% for API handlers

**Test Scenarios:**
1. **Success Cases:**
   - Block queries return correct data
   - Transaction queries return correct data
   - Address history returns correct paginated results
   - Event log filtering returns correct filtered results
   - Chain statistics return accurate counts and lag

2. **Error Cases:**
   - 404 for non-existent blocks/transactions
   - 400 for invalid pagination parameters
   - 400 for invalid address/hash formats
   - 500 for database connection failures (mock)

3. **Edge Cases:**
   - Empty result sets (no transactions for address)
   - Pagination edge cases (offset > total, limit = 0)
   - Large limit values (enforce max limits)
   - Nullable fields (to_addr for contract creation)

4. **Integration Tests:**
   - End-to-end API requests with test database
   - Pagination correctness across multiple pages
   - Query performance under realistic load
   - Concurrent request handling

5. **Performance Tests:**
   - Load test with 100 concurrent requests
   - Measure p95 latency for each endpoint
   - Verify database query plans use indexes

### API Design Notes

**Consistency:**
- All timestamps in Unix epoch seconds (consistent with blockchain data)
- All hex values prefixed with `0x` (Ethereum convention)
- All BigInt values returned as strings (JSON safe, no precision loss)
- All error responses follow standard format: `{error: "message", details: "..."}`

**Pagination:**
- Default limits: blocks=25, transactions=50, logs=100
- Max limits: blocks=100, transactions=100, logs=1000
- Pagination metadata included in all list responses: `{data: [...], total, limit, offset}`
- Offset-based pagination sufficient for demo scale (cursor-based out of scope)

**CORS:**
- Allow all origins (`*`) for demo/portfolio
- Configurable via API_CORS_ORIGINS environment variable
- Preflight requests handled automatically by CORS middleware

**Error Codes:**
- 200: Success
- 400: Bad Request (invalid input)
- 404: Not Found (resource doesn't exist)
- 500: Internal Server Error (database failure, unexpected errors)
- 503: Service Unavailable (health check failure)

### References

- [Source: docs/tech-spec-epic-2.md#Story-2.1-REST-API-Endpoints]
- [Source: docs/tech-spec-epic-2.md#API-Specification]
- [Source: docs/solution-architecture.md#API-Server-Components]
- [Source: docs/PRD.md#FR004-FR008 (API Functional Requirements)]
- [Source: docs/PRD.md#NFR002 (API Latency <150ms)]
- [chi Router Documentation: https://github.com/go-chi/chi]
- [pgx Documentation: https://pkg.go.dev/github.com/jackc/pgx/v5]
- [Prometheus Go Client: https://pkg.go.dev/github.com/prometheus/client_golang/prometheus]

---

## Dev Agent Record

### Context Reference

- Story Context: `docs/stories/2-1-rest-api-endpoints-for-blockchain-queries.context.xml`

### Agent Model Used

{{agent_model_name_version}}

### Debug Log References

### Completion Notes List

### File List

---

## Change Log

- 2025-10-30: Story created from epic 2 tech-spec by create-story workflow
